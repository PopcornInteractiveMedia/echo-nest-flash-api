<?xml version="1.0" encoding="utf-8"?>

<!--

This example uses the Echo Nest API to remix the track by altering the
arrangement of the bars of the track.

The remixes are based on the examples distributed with the Echo Nest remix API.

This example depends on three additional libraries:

  as3corelib for MD5 calculation
  http://code.google.com/p/as3corelib/

  MP3FileReferenceLoaderLib to load sound files directly from a FileReference
  http://www.flexiblefactory.co.uk/flexible/?p=46

  com.ryanberdeen.audio for the actual remixing
  http://github.com/also/flash-audio/tree/master

-->

<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" creationComplete="init();" paddingTop="0" paddingRight="0" paddingBottom="0" paddingLeft="0">
  <mx:VBox width="100%">
    <mx:HBox paddingBottom="10">
      <mx:Button id="browseButton" label="Choose a songâ€¦" click="chooseFile();"/>
      <mx:CheckBox id="calculateMd5checkBox" label="Check for analysis before uploading" selected="true"/>
    </mx:HBox>
    <mx:ProgressBar id="progressBar" mode="manual" label="" width="100%"/>
    <mx:HRule width="100%"/>
    <mx:HBox>
      <mx:Button id="remixButton" label="Remix" enabled="false" click="remixButtonHandler();"/>
      <mx:Button id="playButton" label="Play" enabled="false" click="togglePlayPause();"/>
    </mx:HBox>
    <!--<mx:TextArea id="logTextArea" width="100%" height="200" editable="false" valueCommit="logTextArea.verticalScrollPosition=logTextArea.maxVerticalScrollPosition"/>-->
  </mx:VBox>

  <mx:Script><![CDATA[
    import com.adobe.crypto.MD5Stream;
    import com.adobe.serialization.json.JSON;
    import com.ryanberdeen.echonest.api.v3.EchoNestError;
    import com.ryanberdeen.echonest.api.v3.TrackApi
    import com.ryanberdeen.audio.ISampleSource;
    import com.ryanberdeen.audio.DiscontinuousSampleSource;
    import com.ryanberdeen.audio.SampleRange;
    import com.ryanberdeen.audio.SampleSourcePlayer;
    import com.ryanberdeen.audio.SoundSampleSource;

    import flash.events.Event;
    import flash.media.Sound;
    import flash.net.FileReference;
    import flash.net.URLLoader;
    import flash.utils.Timer;

    import mx.collections.ArrayCollection;

    import org.audiofx.mp3.MP3FileReferenceLoader;
    import org.audiofx.mp3.MP3SoundEvent;

    private var trackApi:TrackApi = new TrackApi();

    private var fileReference:FileReference;
    private var mp3Loader:MP3FileReferenceLoader;
    private var sound:Sound;

    private var md5LoopTimer:Timer;
    private var md5Stream:MD5Stream;
    private var md5Bytes:ByteArray;

    private var trackId:String;
    private var trackMd5:String;

    private var bars:Array;
    private var beats:Array;

    private var remixPlayer:SampleSourcePlayer;
    private var samples:Array;
    private var playing:Boolean;
    private var positionUpdateTimer:Timer;

    private function init():void {
      trackApi.apiKey = YOUR_API_KEY;
      log('<b>loaded remix demo</b>');

      positionUpdateTimer = new Timer(10);
      positionUpdateTimer.addEventListener('timer', positionUpdateTimerHandler);
      ExternalInterface.addCallback('setRemixJson', setRemixJson);
      callJs('init');
    }

    private function log(o:Object):void {
      //logTextArea.htmlText += o + "\n";
    }

    private function setStatus(status:String, indeterminate:Boolean = false):void {
      progressBar.label = status;
      progressBar.indeterminate = indeterminate;
      if (indeterminate) {
        progressBar.mode = 'event';
      }
    }

    private function clearStatus():void {
      progressBar.label = '';
      progressBar.indeterminate = false;
      progressBar.mode = 'manual';
    }

    private function resetAnalysis():void {
      bars = null;
      beats = null;
      playButton.enabled = false;
      remixButton.enabled = false;
      if (md5LoopTimer != null) {
        md5LoopTimer.stop();
        md5LoopTimer = null;
      }

      sound = null;
      samples = null;

      resetPlayer();
    }

    private function chooseFile():void {
      log('<b>choosing file...</b>');
      resetAnalysis();
      fileReference = new FileReference();
      fileReference.addEventListener(Event.SELECT, function(e:Event):void {
        log('selected file ' + fileReference.name);
        loadSound(); // the mp3 loaded will load the file data
      });
      fileReference.browse();
    }

    private function loadSound():void {
      log('<b>loading sound...</b>');
      mp3Loader = new MP3FileReferenceLoader();
      mp3Loader.addEventListener(Event.COMPLETE, handleSoundLoadComplete);
      mp3Loader.getSound(fileReference);
    }

    private function handleSoundLoadComplete(e:MP3SoundEvent):void {
      log('sound loaded');
      mp3Loader.removeEventListener(Event.COMPLETE, handleSoundLoadComplete);
      sound = e.sound;

      if (calculateMd5checkBox.selected) {
        calculateMd5();
      }
      else {
        uploadFile();
      }
    }

    private function calculateMd5():void {
      log('<b>calculating md5...</b>');
      md5Stream = new MD5Stream();
      fileReference.data.position = 0;
      md5Bytes = new ByteArray();
      setStatus('Calculate MD5');
      md5LoopTimer = new Timer(1);
      md5LoopTimer.addEventListener('timer', function md5LoopIterate(e:Event):void {
        if (fileReference.data.bytesAvailable == 0) {
          trackMd5 = md5Stream.complete();
          md5LoopTimer.stop();
          handleCalculateMd5Complete();
          return;
        }

        var length:int = Math.min(51200, fileReference.data.bytesAvailable);
        md5Bytes.length = length;
        fileReference.data.readBytes(md5Bytes, 0, length);
        md5Stream.update(md5Bytes);
        progressBar.setProgress(fileReference.data.position, fileReference.data.length);
      });
      md5LoopTimer.start();
    }

    private function handleCalculateMd5Complete():void {
      log('md5 calculated ' + trackMd5);
      md5Stream = null;
      md5Bytes = null;
      clearStatus();
      checkStatus();
    }

    private function checkStatus():void {
      log('<b>checking for analysis...</b>');
      setStatus('Check for analysis', true);
      trackApi.getMetadata({md5: trackMd5}, {
        onResponse: metadataResponseHandler,
        onEchoNestError: echoNestErrorHandler
      });
    }

    private function metadataResponseHandler(metadata:Object):void {
      if (metadata.status == 'COMPLETE') {
        log('track analysis found');
        trackId = metadata.id;
        loadAnalysis();
      }
      else if (metadata.status == 'PENDING') {
        log('track analysis pending');
        waitForAnalysis();
      }
      else if (metadata.status == 'ERROR') {
        log('track analysis has failed. try a different track');
      }
      else {
        log('track analysis not found');
        uploadFile();
      }
    }

    private function uploadFile():void {
      log('<b>uploading track...</b>');
      setStatus('Upload');
      trackApi.uploadFileReference({file: fileReference, wait: 'N'}, {
        onResponse: function(track:Object):void {
          trackId = track.id;
          log('uploaded track ' + track.id);
          clearStatus();
          waitForAnalysis();
        },
        onProgress: function(e:ProgressEvent):void {
          progressBar.setProgress(e.bytesLoaded, e.bytesTotal);
        },
        onEchoNestError: function(error:EchoNestError):void {
          log('error ' + error.code + ': ' + error.description);
        },
        onError: function(e:Event):void {
          log(e.toString());
        }
      });
    }

    private function waitForAnalysis():void {
      log('<b>waiting for analysis...</b>');
      setStatus('Wait for analysis', true);
      trackApi.getMetadata({md5: trackMd5}, {
        onResponse: function(metadata:Object):void {
          if (metadata.status == 'PENDING') {
            // try again in 5 seconds
            setTimeout(waitForAnalysis, 5000);
            log('analysis pending');
          }
          else if (metadata.status == 'COMPLETE') {
            log('analysis complete');
            clearStatus();
            loadAnalysis();
          }
          else {
            log('analysis failed');
          }
        },
        onEchoNestError: function(e:EchoNestError):void {
          if (e.code == 11) { // Analysis not ready (please try again in a few minutes)
            // try again in 15 seconds
            setTimeout(waitForAnalysis, 15000);
          }
          else {
            clearStatus();
            echoNestErrorHandler(e);
          }
        }
      });
    }

    private function loadAnalysis():void {
      log('<b>loading analysis...</b>');
      setStatus('Download analysis', true);
      this.beats = null;
      this.bars = null;
      var beatsLoader:URLLoader = trackApi.getBeats({id: trackId}, {
        onResponse: beatsLoadedHandler,
        onEchoNestError: echoNestErrorHandler
      });

      var barsLoader:URLLoader = trackApi.getBars({id: trackId}, {
        onResponse: barsLoadedHandler,
        onEchoNestError: echoNestErrorHandler
      });
    }

    private function echoNestErrorHandler(error:EchoNestError):void {
      log('error ' + error.code + ': ' + error.description);
      clearStatus();
    }

    private function beatsLoadedHandler(beats:Array):void {
      this.beats = beats;
      log('loaded ' + beats.length + ' beats');
      if (bars) {
        analysisLoadedHandler();
      }
    }

    private function barsLoadedHandler(bars:Array):void {
      this.bars = bars;
      log('loaded ' + bars.length + ' bars');
      if (beats) {
        analysisLoadedHandler();
      }
    }

    private function analysisLoadedHandler():void {
      log('analysis loaded');
      callJs('setAnalysis', {bars: bars, beats: beats});
      clearStatus();
      remixButton.enabled = true;
      preparePlayer();
    }

    private function resetPlayer():void {
      if (remixPlayer != null) {
        remixPlayer.stop();

        remixPlayer = null;
      }
      playButton.label = "Play";
      playing = false;
      callJs('setProgress', 0);
      positionUpdateTimer.stop();
    }

    private function preparePlayer():void {
      resetPlayer();

      remixPlayer = new SampleSourcePlayer();
      remixPlayer.addEventListener(Event.SOUND_COMPLETE, playerSoundCompleteHandler);
      if (samples) {
        remixPlayer.sampleSource = discontinuousRemix(samples);
        enablePlayer();
      }
    }

    private function enablePlayer():void {
      playButton.enabled = true;
      playButton.label = "Play";
    }

    private function playerSoundCompleteHandler(e:Event):void {
      try {
      positionUpdateTimer.stop();
      preparePlayer();
      }catch(e:Error) {log(e.getStackTrace())}
    }

    private function discontinuousRemix(sampleRanges:Array):ISampleSource {
      var sampleSource:DiscontinuousSampleSource = new DiscontinuousSampleSource();

      sampleSource.sampleRanges = sampleRanges;
      sampleSource.sampleSource = new SoundSampleSource(sound);

      return sampleSource;
    }

    private function togglePlayPause():void {
      if (!playing) {
        play();
      }
      else {
        pause();
      }
    }

    private function play():void {
      try {
      remixPlayer.start();
      positionUpdateTimer.start();
      playButton.label = "Pause";
      playing = true;
      }catch(e:Error) {log(e.getStackTrace())}
    }

    private function pause():void {
      remixPlayer.stop();
      positionUpdateTimer.stop();
      playButton.label = "Play";
      playing = false;
    }

    private function positionUpdateTimerHandler(e:Event):void {
      callJs('setProgress', remixPlayer.sourcePosition / (sound.length * 44.1))
    }

    private function callJs(fn:String, ...args):* {
      args.unshift('Remix.__' + fn);
      return ExternalInterface.call.apply(ExternalInterface, args);
    }

    private function remixButtonHandler():void {
      preparePlayer();
      callJs('remix');
    }

    private function setRemixJson(json:String):void {
      var array:Array = JSON.decode(json);
      var result:Array = [];
      for (var i:int = 0; i < array.length - 1; i++) {
        result.push(new SampleRange(Math.round(array[i] * 44100), Math.round(array[++i] * 44100)));
      }

      setRemix(result);
      play();
    }

    private function setRemix(sampleRanges:Array):void {
      samples = sampleRanges;
      remixPlayer.sampleSource = discontinuousRemix(sampleRanges);
      preparePlayer();
    }
  ]]></mx:Script>
</mx:Application>
